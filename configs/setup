#!/usr/bin/env zx
await $`uname`
let key = "";
const handleDecrypt = async (file, target) => {
  const crypto = require("crypto")
  const file_content = await fs.readFile(file)
  if(!key.length) {
    key = await question("Decryption passphrase: ");
  }
  const keySize = 32;
  const salt = file_content.subarray(0, 16);
  const keyBuffer = crypto.pbkdf2Sync(key, salt, 10000, keySize, 'sha256');
  const iv = file_content.subarray(16, 32)
  const decipher = crypto.createDecipheriv('aes-256-cbc', keyBuffer, iv);
  let decrypted = decipher.update(file_content.subarray(32));
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  await fs.writeFile(file.replace(".crypt", ""), decrypted)
  await $`ln -s ${file.replace(".crypt", "")} ${target}`
  await $`chmod 600 ${file.replace(".crypt", "")}`
  await $`chmod 600 ${target}`
}
const checked = []
const probe = async target => {
  if(checked.includes(target))
    return
   console.log("probing", target)
   const exists = await fs.exists(target);
   if(exists) {
     const del = await question(target + " exists, delete? ");
     if(del !== "y") {
     process.exit(1);
     } else {
       const stat = await fs.stat(target);
       if(stat.isDirectory()) {
            await fs.rm(target, { recursive: true, force: true });
      } else {
          await fs.unlink(target)
      }
     }
  }
  checked.push(target);
}
const top_dirs = await fs.readdir(__dirname);
const platform = process.platform;
if(platform === "win32") {
  console.log("todo")
  process.exit(0);
}
const hp = os.homedir();
const dr = __dirname;
const EXCLUDE = ["setup", "encrypt", ".", "..", ".DS_Store", "setup.mjs"];
const BASE_DIRS = [".config", "Stuff"];
for(const dir of top_dirs) {
  if(EXCLUDE.includes(dir))
    continue;
  if(! (await fs.exists(dir)))
    continue;
  if((await fs.stat(path.join(dr, dir))).isFile()) {
    if(dir.endsWith(".crypt")) {
       await probe(path.join(hp, dir.replace(".crypt", "")))
       await probe(path.join(dir.replace(".crypt", "")))
    } else {
      await probe(path.join(hp, dir))
    }
    continue;
  }
  const files = await fs.readdir(path.join(dr, dir));
  for(const f of files) {
    const stats = await fs.stat(path.join(dr, dir, f));
    if(stats.isDirectory() && BASE_DIRS.includes(f)) {
      const directory_target = path.join(hp, f);
      await probe(path.join(directory_target, dir))
    } else if (stats.isFile()) {
       const directory_target = path.join(hp, dir);
       await probe(directory_target)
       if(f.endsWith(".crypt")) {
          await probe(path.join(directory_target, f.replace(".crypt","")))
          await probe(path.join(dr, dir, f.replace(".crypt", "")))
      } else {
          await probe(path.join(directory_target, f))
      }
    }
  }

}

for(const dir of top_dirs) {
  if(EXCLUDE.includes(dir))
    continue;
  if(! (await fs.exists(dir)))
    continue;
  if((await fs.stat(path.join(__dirname, dir))).isFile()) {
    if(dir.endsWith(".crypt"))
      await handleDecrypt(path.join(__dirname, dir), path.join(os.homedir(), dir.replace(".crypt", "")))
    else
      await $`ln -s ${path.join(__dirname, dir)} ${path.join(os.homedir(), dir)}`
    continue;
  }
  const files = await fs.readdir(path.join(__dirname, dir));
  for(const f of files) {
    const stats = await fs.stat(path.join(__dirname, dir, f));
    if(stats.isDirectory() && BASE_DIRS.includes(f)) {
      const directory_target = path.join(os.homedir(), f);
      if(! (await fs.exists(directory_target)))
        await fs.mkdir(directory_target)
      await $`ln -s "${path.join(__dirname, dir, f)}" "${path.join(directory_target, dir)}"`
    } else if (stats.isFile()) {
      const directory_target = path.join(os.homedir(), dir);
      if(! (await fs.exists(directory_target)))
        await fs.mkdir(directory_target)
      if(f.endsWith(".crypt"))
        await handleDecrypt(path.join(__dirname, dir, f), path.join(os.homedir(), dir, f.replace(".crypt", "")))
      else
        await $`ln -s "${path.join(__dirname, dir, f)}" "${path.join(os.homedir(), dir, f)}"`
    }
  }

}

